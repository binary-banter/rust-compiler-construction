use std::str::FromStr;
use crate::language::lvar::*;
use crate::passes::parse::PrgParsed;
use crate::passes::type_check::Type;

grammar;

match {
    r"[0-9]+",
    r"[_a-zA-Z][_a-zA-Z0-9]*",
    "fn",
    "(",
    ")",
    "{",
    "}",
    "->",
    "+",
    "-",
    "*",
    "/",
    "%",
    "read",
    "print",
    "let",
    "=",
    ";",
    "Int",
    "Bool",

    r"\s+" => {},
}

pub Program: PrgParsed<'input> = {
    <defs: Def*> => PrgParsed{ defs, entry: "main" }
}

Def: Def<&'input str> = Fn;

Fn: Def<&'input str> = {
    "fn" <sym:Ident> "(" ")" "->" <typ:Type> "{" <bdy: Expr> "}" => Def::Fn { sym, params: vec![], typ, bdy }
}

Type: Type = {
    "Int" => Type::Int,
    "Bool" => Type::Bool,
}

BinaryOps<Op,Next>: Expr<&'input str> = {
    <e1:BinaryOps<Op,Next>> <op:Op> <e2:Next> => Expr::Prim{op, args: vec![e1, e2] },
    Next
};



Expr = ExprStmt;

ExprStmt: Expr<&'input str> = {
    "let" <sym:Ident> "=" <bnd:ExprAdditive> ";" <bdy:ExprStmt> => Expr::Let { sym, bnd: Box::new(bnd), bdy: Box::new(bdy) },
    ExprAdditive
}

ExprAdditive = BinaryOps<AdditiveOp, ExprMultiplicative>;
ExprMultiplicative = BinaryOps<MultiplicativeOp, ExprUnary>;

AdditiveOp: Op = {
    "+" => Op::Plus,
    "-" => Op::Minus,
};
MultiplicativeOp: Op = {
   "*" => Op::Mul,
   "/" => Op::Div,
   "%" => Op::Mod,
};
UnaryOp: Op = {
    "-" => Op::Minus,
}

ExprUnary: Expr<&'input str> = {
    <op:UnaryOp> <e:ExprUnary> => Expr::Prim{op, args: vec![e]},
    ExprCall
}

ExprCall: Expr<&'input str> = {
    "read" "(" ")" => Expr::Prim{ op: Op::Read, args: vec![] },
    "print" "(" <e: Expr> ")" => Expr::Prim{ op: Op::Print, args: vec![e] },
    ExprAtom
}

ExprAtom: Expr<&'input str> = {
    Num => Expr::Lit{ val: Lit::Int { val: <> }},
    Ident => Expr::Var { sym: <> },
    "(" <Expr> ")",
};

Ident: &'input str = r"[_a-zA-Z][_a-zA-Z0-9]*";

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();
