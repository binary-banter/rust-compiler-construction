use std::str::FromStr;
use crate::passes::parse::*;
use crate::passes::parse::PrgParsed;
use crate::passes::type_check::Type;

grammar;

match {
    // Keywords
    "fn",
    "let",
    "if",
    "else",
    "loop",
    "break",
    "mut",

    // Structural tokens
    "(",
    ")",
    "{",
    "}",
    "->",
    "=",
    ";",
    ",",
    ":",

    // Identifier
    r"[_a-zA-Z][_a-zA-Z0-9]*",

    // Integer operators
    "+",
    "-",
    "*",
    "/",
    "%",

    // Cursed build-in functions
    "read",
    "print",

    // Types
    "Int",
    "Bool",
    "Unit",
    "Never",

    // Literals
    "true",
    "false",
    "unit",
    r"[0-9]+",

    // Logical operators
    "^",
    "&&",
    "||",
    "!",

    // Compartive operators
    "==",
    "!=",
    ">",
    ">=",
    "<",
    "<=",

    // Whitespaces
    r"\s+" => {},
}

pub Program: PrgParsed<'input> = {
    <defs: Def*> => PrgParsed{ defs, entry: "main" }
}

Def: Def<&'input str, Expr<&'input str>> = Fn;

Fn: Def<&'input str, Expr<&'input str>> = {
    "fn" <sym:Ident> "(" <params:Comma<Param>> ")" <typ:("->" <Type>)?> "{" <bdy: Expr> "}" => Def::Fn { sym, params, typ: typ.unwrap_or(Type::Unit), bdy }
}

Param = <Ident> ":" <Type>;

Type: Type = {
    "Int" => Type::Int,
    "Bool" => Type::Bool,
    "Unit" => Type::Unit,
    "Never" => Type::Never,
}

BinaryOps<Op,Next>: Expr<&'input str> = {
    <e1:BinaryOps<Op,Next>> <op:Op> <e2:Next> => Expr::Prim{op, args: vec![e1, e2] },
    Next,
}

Expr = ExprStmt;

ExprStmt: Expr<&'input str> = {
    "let" <mutable:"mut"?> <sym:Ident> "=" <bnd:ExprLogicalOr> ";" => Expr::Let { sym, mutable: mutable.is_some(), bnd: Box::new(bnd), bdy: Box::new(Expr::Lit { val: Lit::Unit }) },
    "let" <mutable:"mut"?> <sym:Ident> "=" <bnd:ExprLogicalOr> ";" <bdy:ExprStmt> => Expr::Let { sym, mutable: mutable.is_some(), bnd: Box::new(bnd), bdy: Box::new(bdy) },
    <stmt:ExprInStmt> ";" => Expr::Seq { stmt: Box::new(stmt), cnt: Box::new(Expr::Lit { val: Lit::Unit }) },
    <stmt:ExprInStmt> ";" <cnt:ExprStmt> => Expr::Seq { stmt: Box::new(stmt), cnt: Box::new(cnt) },
    ExprInStmt,
}

ExprInStmt: Expr<&'input str> = {
    <sym:Ident> "=" <bnd:ExprLogicalOr> => Expr::Assign { sym, bnd: Box::new(bnd), bdy: Box::new(Expr::Lit { val: Lit::Unit }) },
    "if" <cnd:ExprLogicalOr> "{" <thn:Expr> "}" "else" "{" <els:Expr> "}" => Expr::If { cnd: Box::new(cnd), thn: Box::new(thn), els: Box::new(els) },
    "loop" "{" <bdy:Expr> "}" => Expr::Loop { bdy: Box::new(bdy) },
    "break" <bdy:ExprLogicalOr?> => Expr::Break { bdy: bdy.map(Box::new) },
    ExprLogicalOr,
}

ExprLogicalOr = BinaryOps<LogicalOrOp, ExprLogicalAnd>;
ExprLogicalAnd = BinaryOps<LogicalAndOp, ExprComparative>;
ExprComparative = BinaryOps<ComparativeOp, ExprXor>;
ExprXor = BinaryOps<XorOp, ExprAdditive>;
ExprAdditive = BinaryOps<AdditiveOp, ExprMultiplicative>;
ExprMultiplicative = BinaryOps<MultiplicativeOp, ExprUnary>;

LogicalOrOp: Op = "||" => Op::LOr;
LogicalAndOp: Op = "&&" => Op::LAnd;
ComparativeOp: Op = {
    "==" => Op::EQ,
    "!=" => Op::NE,
    ">" => Op::GT,
    ">=" => Op::GE,
    "<" => Op::LT,
    "<=" => Op::LE,
}
XorOp: Op = "^" => Op::Xor;
AdditiveOp: Op = {
    "+" => Op::Plus,
    "-" => Op::Minus,
}
MultiplicativeOp: Op = {
   "*" => Op::Mul,
   "/" => Op::Div,
   "%" => Op::Mod,
}
UnaryOp: Op = {
    "-" => Op::Minus,
    "!" => Op::Not,
}

ExprUnary: Expr<&'input str> = {
    <op:UnaryOp> <e:ExprUnary> => Expr::Prim{op, args: vec![e]},
    ExprCall,
}

ExprCall: Expr<&'input str> = {
    "read" "(" ")" => Expr::Prim{ op: Op::Read, args: vec![] },
    "print" "(" <e: Expr> ")" => Expr::Prim{ op: Op::Print, args: vec![e] },
    <fun:ExprAtom> "(" <args:Comma<Expr>> ")" => Expr::Apply{ fun: Box::new(fun), args },
    ExprAtom,
}

ExprAtom: Expr<&'input str> = {
    Num => Expr::Lit{ val: Lit::Int { val: <> }},
    Bool => Expr::Lit { val: Lit::Bool { val: <> }},
    "unit" => Expr::Lit { val: Lit::Unit },
    Ident => Expr::Var { sym: <> },
    "(" <Expr> ")",
}

Ident: &'input str = r"[_a-zA-Z][_a-zA-Z0-9]*";

Num: i64 = <s:r"[0-9]+"> => i64::from_str(s).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
