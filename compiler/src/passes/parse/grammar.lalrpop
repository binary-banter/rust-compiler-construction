use crate::passes::parse::{
    BinaryOp, DefParsed, ExprParsed, InstrParsed, Lit, Meta, Param, PrgParsed, Spanned, Type, TypeDef, UnaryOp, types::IntType,
};
use crate::passes::select::{VarArg, Reg};
use functor_derive::Functor;
use crate::passes::validate::Int;
use crate::passes::select::Size;

grammar;

match {
    // Keywords
    "fn",
    "let",
    "if",
    "else",
    "loop",
    "while",
    "break",
    "continue",
    "return",
    "mut",
    "struct",
    "enum",
    "switch",
    "asm",

    // Asm instructions
    "addq",
    "subq",
    "mulq",
    "divq",
    "negq",
    "movq",
    "pushq",
    "popq",
    "retq",
    "andq",
    "orq",
    "xorq",
    "notq",
    "cmpq",
    "syscall",

    // Asm registers
    "%RSP",
    "%RBP",
    "%RAX",
    "%RBX",
    "%RCX",
    "%RDX",
    "%RSI",
    "%RDI",
    "%R8",
    "%R9",
    "%R10",
    "%R11",
    "%R12",
    "%R13",
    "%R14",
    "%R15",

    // Structural tokens
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    "->",
    "=",
    ";",
    ",",
    ":",
    ".",
    "::",
    "=>",
    "$",

    // Identifier
    r"[_a-zA-Z][_a-zA-Z0-9]*" => identifier,

    // Int operators
    "+",
    "-",
    "*",
    "/",
    "%",

    // Types
    "I8",
    "U8",
    "I16",
    "U16",
    "I32",
    "U32",
    "I64",
    "U64",
    "Bool",
    "Unit",
    "Never",

    // Literals
    "true",
    "false",
    "unit",
    r"0b[01]([01_]*[01])?([iu](8|16|32|64))?" => binary,
    r"0o[0-7]([0-7_]*[0-7])?([iu](8|16|32|64))?" => octal,
    r"[0-9]([0-9_]*[0-9])?([iu](8|16|32|64))?" => decimal,
    r"0x[0-9a-fA-F]([0-9a-fA-F_]*[0-9a-fA-F])?([iu](8|16|32|64))?" => hexadecimal,
    r"b'(\\)?[^'[[:cntrl:]]]'([iu](8|16|32|64))?" => character,

    // Logical operators
    "^",
    "&&",
    "||",
    "!",

    // Compartive operators
    "==",
    "!=",
    ">",
    ">=",
    "<",
    "<=",

    // Whitespaces
    r"\s+" => {},

    // Line comments
    r"//[^\n]*\n" => {},

    // Block comments
    r"/\*([^*]|(\*[^/]))*\*/" => {},
}

pub Program: PrgParsed<'input> = {
    <defs: Def*> => PrgParsed {
        defs,
        entry: "main",
    }
}

Def: DefParsed<'input> = {
    "struct" <sym:Ident> "{" <fields:Comma<(<Ident> ":" <Type>)>> "}" => DefParsed::TypeDef {
        sym,
        def: TypeDef::Struct { fields },
    },
    "enum" <sym:Ident> "{" <variants:Comma<(<Ident> ":" <Type>)>> "}" => DefParsed::TypeDef {
        sym,
        def: TypeDef::Enum { variants },
    },
    "fn" <sym:Ident> "(" <params:Comma<Param>> ")" <typ:("->" <Type>)?> "{" <bdy: Spanned<Expr?>> "}" => DefParsed::Fn {
        sym,
        params,
        typ: typ.unwrap_or(Type::Unit),
        bdy: bdy.fmap(|bdy| bdy.unwrap_or(ExprParsed::Lit { val: Lit::Unit })),
    },
}

Param: Param<Spanned<&'input str>> = {
    <mutable:"mut"?> <sym:Ident> ":" <typ:Type> => Param {
        mutable: mutable.is_some(),
        sym,
        typ,
    }
}

Type: Type<Spanned<&'input str>> = {
    "I8" => Type::Int(IntType::I8),
    "U8" => Type::Int(IntType::U8),
    "I16" => Type::Int(IntType::I16),
    "U16" => Type::Int(IntType::U16),
    "I32" => Type::Int(IntType::I32),
    "U32" => Type::Int(IntType::U32),
    "I64" => Type::Int(IntType::I64),
    "U64" => Type::Int(IntType::U64),
    "Bool" => Type::Bool,
    "Unit" => Type::Unit,
    "Never" => Type::Never,
    <sym:Ident> => Type::Var { sym },
}

// We have the following precedence:
// ExprStmt
// ExprInStmt
// ExprLogicalOr
// ExprLogicalAnd
// ExprComparative
// ExprXor
// ExprAdditive
// ExprMultiplicative
// ExprUnary
// ExprAccess
// ExprCall
// ExprAtom
// Num/Bool/Ident
Expr = ExprStmt;

ExprStmt: ExprParsed<'input> = {
    ";" => ExprParsed::Lit { val: Lit::Unit },
    "let" <mutable:"mut"?> <sym:Ident> <typ:(":" <Type>)?> "=" <bnd:Spanned<ExprLogicalOr<Struct>>> ";" <bdy:Spanned<ExprStmt?>> => ExprParsed::Let {
        sym,
        mutable: mutable.is_some(),
        typ,
        bnd: Box::new(bnd),
        bdy: Box::new(bdy.fmap(|bdy| bdy.unwrap_or(ExprParsed::Lit { val: Lit::Unit }))),
    },
    <stmt:Spanned<ExprWithBlock>> ";"? <cnt:Spanned<ExprStmt>> => ExprParsed::Seq {
        stmt: Box::new(stmt),
        cnt: Box::new(cnt),
    },
    <stmt:Spanned<ExprWithoutBlock>> ";" <cnt:Spanned<ExprStmt?>> => ExprParsed::Seq {
        stmt: Box::new(stmt),
        cnt: Box::new(cnt.fmap(|cnt| cnt.unwrap_or(ExprParsed::Lit { val: Lit::Unit }))),
    },
    ExprWithBlock,
    ExprWithoutBlock,
}

ExprWithBlock: ExprParsed<'input> = {
    ExprIf,
    "loop" "{" <bdy:Spanned<Expr?>> "}" => ExprParsed::Loop {
        bdy: Box::new(bdy.fmap(|cnt| cnt.unwrap_or(ExprParsed::Lit { val: Lit::Unit }))),
    },
    // todo: this should become a proper expression that gets "desugared" in its own pass
    <l:@L> "while" <r:@R> <cnd:Spanned<ExprLogicalOr<Never>>> "{" <bdy:Spanned<Expr>> "}" => ExprParsed::Loop {
        bdy: Box::new(Meta {
            meta: (l, r - l),
            inner: ExprParsed::If {
                cnd: Box::new(cnd),
                thn: Box::new(bdy),
                els: Box::new(Meta {
                    meta: (l, r - l),
                    inner: ExprParsed::Seq {
                        stmt: Box::new(Meta {
                            meta: (l, r - l),
                            inner: ExprParsed::Break { bdy: Box::new(Meta {
                                meta: (l, r - l),
                                inner: ExprParsed::Lit { val: Lit::Unit },
                            })},
                        }),
                        cnt: Box::new(Meta {
                            meta: (l, r - l),
                            inner: ExprParsed::Lit { val: Lit::Unit },
                        }),
                    },
                }),
            },
        }),
    },
    "asm" "{" <instrs:AsmInstr*> "}" => ExprParsed::Asm { instrs },
    "switch" <enm:Spanned<ExprLogicalOr<Never>>> "{" <arms:Comma<(<Ident> "(" <Ident> ")" "=>" <Spanned<Expr>> )>> "}"  => ExprParsed::Switch {
        enm: Box::new(enm),
        arms: arms.into_iter().map(|(s1, s2, e)| (s1, s2, Box::new(e))).collect(),
    },
}

ExprIf: ExprParsed<'input> = {
    "if" <cnd:Spanned<ExprLogicalOr<Never>>> "{" <thn:Spanned<Expr>> "}" <l:@L> <els:("else" <Spanned<ExprIfElse>>)?> <r:@R> => ExprParsed::If {
        cnd: Box::new(cnd),
        thn: Box::new(thn),
        els: Box::new(els.unwrap_or(Meta { meta: (l, r - l), inner: ExprParsed::Lit { val: Lit::Unit }})),
    },
}

ExprWithoutBlock: ExprParsed<'input> = {
    <sym:Ident> "=" <bnd:Spanned<ExprLogicalOr<Struct>>> => ExprParsed::Assign {
        sym,
        bnd: Box::new(bnd),
    },
    "break" <bdy:Spanned<ExprLogicalOr<Struct>?>> => ExprParsed::Break {
        bdy: Box::new(bdy.fmap(|bdy| bdy.unwrap_or(ExprParsed::Lit { val: Lit::Unit }))),
    },
    "return" <bdy:Spanned<ExprLogicalOr<Struct>?>> => ExprParsed::Return {
        bdy: Box::new(bdy.fmap(|bdy| bdy.unwrap_or(ExprParsed::Lit { val: Lit::Unit }))),
    },
    "continue" => ExprParsed::Continue,
    ExprLogicalOr<Struct>,
}

ExprIfElse: ExprParsed<'input> = {
    "{" <Expr> "}",
    ExprIf,
}

BinaryOps<Op,Next>: ExprParsed<'input> = {
    <e1:Spanned<BinaryOps<Op,Next>>> <op:Op> <e2:Spanned<Next>> => ExprParsed::BinaryOp {
        op,
        exprs: [Box::new(e1), Box::new(e2)],
    },
    Next,
}

ExprLogicalOr<T> = BinaryOps<LogicalOrOp, ExprLogicalAnd<T>>;
ExprLogicalAnd<T> = BinaryOps<LogicalAndOp, ExprComparative<T>>;
ExprComparative<T> = BinaryOps<ComparativeOp, ExprXor<T>>;
ExprXor<T> = BinaryOps<XorOp, ExprAdditive<T>>;
ExprAdditive<T> = BinaryOps<AdditiveOp, ExprMultiplicative<T>>;
ExprMultiplicative<T> = BinaryOps<MultiplicativeOp, ExprUnary<T>>;

LogicalOrOp: BinaryOp = "||" => BinaryOp::LOr;
LogicalAndOp: BinaryOp = "&&" => BinaryOp::LAnd;
ComparativeOp: BinaryOp = {
    "==" => BinaryOp::EQ,
    "!=" => BinaryOp::NE,
    ">" => BinaryOp::GT,
    ">=" => BinaryOp::GE,
    "<" => BinaryOp::LT,
    "<=" => BinaryOp::LE,
}
XorOp: BinaryOp = "^" => BinaryOp::Xor;
AdditiveOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}
MultiplicativeOp: BinaryOp = {
   "*" => BinaryOp::Mul,
   "/" => BinaryOp::Div,
   "%" => BinaryOp::Mod,
}
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
}

ExprUnary<T>: ExprParsed<'input> = {
    <op:UnaryOp> <e:Spanned<ExprUnary<T>>> => ExprParsed::UnaryOp {
        op,
        expr: Box::new(e),
    },
    ExprAccess<T>,
}

ExprAccess<T>: ExprParsed<'input> = {
    <strct:Spanned<ExprAccess<T>>> "." <field:Ident> => ExprParsed::AccessField {
        strct: Box::new(strct),
        field,
    },
    ExprCall<T>,
}

ExprCall<T>: ExprParsed<'input> = {
    <fun:Spanned<ExprAtom<T>>> "(" <args:Comma<Spanned<Expr>>> ")" => ExprParsed::Apply {
        fun: Box::new(fun),
        args,
    },
    ExprAtom<T>,
}

ExprAtom<T>: ExprParsed<'input> = {
    <val:Int> => ExprParsed::Lit {
        val: Lit::Int(val),
    },
    <val:Bool> => ExprParsed::Lit { val: Lit::Bool(val) },
    "unit" => ExprParsed::Lit { val: Lit::Unit },
    <sym:Ident> => ExprParsed::Var { sym },
    <enum_sym:Ident> "::" <variant_sym:Ident> "(" <bdy:Spanned<Expr>> ")" => ExprParsed::Variant {
        enum_sym,
        variant_sym,
        bdy: Box::new(bdy),
    },
    "(" <Expr> ")",
    <T>,
}

Struct: ExprParsed<'input> = {
    <sym:Ident> "{" <fields:Comma<StructArg>> "}" => ExprParsed::Struct {
        sym,
        fields,
    },
}

StructArg: (Spanned<&'input str>, Spanned<ExprParsed<'input>>) = {
    <Ident> ":" <Spanned<Expr>>,
    <l:@L> <sym:Ident> <r:@R> => (sym.clone(), Meta { meta: (l, r - l), inner: ExprParsed::Var { sym } })
}

Never: ExprParsed<'input> = {};

Ident: Spanned<&'input str> = Spanned<identifier>;

Bool: bool = {
    "true" => true,
    "false" => false,
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Spanned<T>: Spanned<T> = <l:@L> <inner:T> <r:@R> => Meta { meta: (l, r - l), inner };

AsmInstr: InstrParsed<'input> = {
    "addq" <src:AsmArg> <dst:AsmArg> => InstrParsed::Add { src, dst, size: Size::Bit64 },
    "subq" <src:AsmArg> <dst:AsmArg> => InstrParsed::Sub { src, dst, size: Size::Bit64 },
    "mulq" <src:AsmArg> => InstrParsed::Mul { src, size: Size::Bit64 },
    "divq" <divisor:AsmArg> => InstrParsed::Div { divisor, size: Size::Bit64 },
    "negq" <dst:AsmArg> => InstrParsed::Neg { dst, size: Size::Bit64 },
    "movq" <src:AsmArg> <dst:AsmArg> => InstrParsed::Mov { src, dst, size: Size::Bit64 },
    "pushq" <src:AsmArg> => InstrParsed::Push { src, size: Size::Bit64 },
    "popq" <dst:AsmArg> => InstrParsed::Pop { dst, size: Size::Bit64 },
    "andq" <src:AsmArg> <dst:AsmArg> => InstrParsed::And { src, dst, size: Size::Bit64 },
    "orq" <src:AsmArg> <dst:AsmArg> => InstrParsed::Or { src, dst, size: Size::Bit64 },
    "xorq" <src:AsmArg> <dst:AsmArg> => InstrParsed::Xor { src, dst, size: Size::Bit64 },
    "notq" <dst:AsmArg> => InstrParsed::Not { dst, size: Size::Bit64 },
    "cmpq" <src:AsmArg> <dst:AsmArg> => InstrParsed::Cmp { src, dst, size: Size::Bit64 },
    "syscall" <arity:Int> => InstrParsed::Syscall { arity: arity.parse().expect("internal compiler error :(") },
}

AsmArg: VarArg<Spanned<&'input str>> = {
    <reg:AsmReg> => VarArg::Reg(reg),
    "{" <sym:Ident> "}" => VarArg::XVar(sym),
    "$" <val:Int> => VarArg::Imm(Int::I64(val.parse().expect("Internal compiler error (oh no!): We were too lazy to make a proper error for this"))),
    "[" <reg:AsmReg> "+" <off:Int> "]"  => VarArg::Deref {
        reg,
        off: off.parse().expect("Internal compiler error (oh no!): We were too lazy to make a proper error for this"),
    },
}

Int: &'input str = {
    binary,
    octal,
    decimal,
    hexadecimal,
    character,
}

AsmReg: Reg = {
    "%RSP" => Reg::RSP,
    "%RBP" => Reg::RBP,
    "%RAX" => Reg::RAX,
    "%RBX" => Reg::RBX,
    "%RCX" => Reg::RCX,
    "%RDX" => Reg::RDX,
    "%RSI" => Reg::RSI,
    "%RDI" => Reg::RDI,
    "%R8" => Reg::R8 ,
    "%R9" => Reg::R9 ,
    "%R10" => Reg::R10,
    "%R11" => Reg::R11,
    "%R12" => Reg::R12,
    "%R13" => Reg::R13,
    "%R14" => Reg::R14,
    "%R15" => Reg::R15,
}
