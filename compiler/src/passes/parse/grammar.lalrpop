use crate::passes::parse::{Def, TypeDef, Expr, Lit, BinaryOp, UnaryOp, Param};
use crate::passes::parse::PrgParsed;
use crate::passes::parse::Type;
use functor_derive::Functor;
use crate::passes::parse::Span;
use crate::passes::parse::Meta;

grammar;

match {
    // Keywords
    "fn",
    "let",
    "if",
    "else",
    "loop",
    "while",
    "break",
    "continue",
    "return",
    "mut",
    "struct",
    "enum",
    "switch",

    // Structural tokens
    "(",
    ")",
    "{",
    "}",
    "->",
    "=",
    ";",
    ",",
    ":",
    ".",
    "::",
    "=>",

    // Identifier
    r"[_a-zA-Z][_a-zA-Z0-9]*" => identifier,

    // Integer operators
    "+",
    "-",
    "*",
    "/",
    "%",

    // Types
    "I64",
    "U64",
    "Bool",
    "Unit",
    "Never",

    // Literals
    "true",
    "false",
    "unit",
    r"[0-9]+" => integer,

    // Logical operators
    "^",
    "&&",
    "||",
    "!",

    // Compartive operators
    "==",
    "!=",
    ">",
    ">=",
    "<",
    "<=",

    // Whitespaces
    r"\s+" => {},

    // Line comments
    r"//[^\n]*\n" => {},

    // Block comments
    r"/\*([^*]|(\*[^/]))*\*/" => {},
}

pub Program: PrgParsed<'input> = {
    <defs: Def*> => PrgParsed {
        defs,
        entry: "main",
    }
}

Def: Def<Meta<Span, &'input str>, Meta<Span, &'input str>, Meta<Span, Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span>>> = {
    "struct" <sym:Ident> "{" <fields:Comma<(<Ident> ":" <Type>)>> "}" => Def::TypeDef {
        sym,
        def: TypeDef::Struct { fields },
    },
    "enum" <sym:Ident> "{" <variants:Comma<(<Ident> ":" <Type>)>> "}" => Def::TypeDef {
        sym,
        def: TypeDef::Enum { variants },
    },
    "fn" <sym:Ident> "(" <params:Comma<Param>> ")" <typ:("->" <Type>)?> "{" <bdy: Spanned<Expr?>> "}" => Def::Fn {
        sym,
        params,
        typ: typ.unwrap_or(Type::Unit),
        bdy: bdy.fmap(|bdy| bdy.unwrap_or(Expr::Lit { val: Lit::Unit })),
    },
}

Param: Param<Meta<Span, &'input str>> = {
    <mutable:"mut"?> <sym:Ident> ":" <typ:Type> => Param {
        mutable: mutable.is_some(),
        sym,
        typ,
    }
}

Type: Type<Meta<Span, &'input str>> = {
    "I64" => Type::I64,
    "U64" => Type::U64,
    "Bool" => Type::Bool,
    "Unit" => Type::Unit,
    "Never" => Type::Never,
    <sym:Ident> => Type::Var { sym },
}

// We have the following precedence:
// ExprStmt
// ExprInStmt
// ExprLogicalOr
// ExprLogicalAnd
// ExprComparative
// ExprXor
// ExprAdditive
// ExprMultiplicative
// ExprUnary
// ExprAccess
// ExprCall
// ExprAtom
// Num/Bool/Ident
Expr = ExprStmt;

ExprStmt: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    "let" <mutable:"mut"?> <sym:Ident> "=" <bnd:Spanned<ExprLogicalOr<Struct>>> ";" <bdy:Spanned<ExprStmt?>> => Expr::Let {
        sym,
        mutable: mutable.is_some(),
        bnd: Box::new(bnd),
        bdy: Box::new(bdy.fmap(|bdy| bdy.unwrap_or(Expr::Lit { val: Lit::Unit }))),
    },
    <stmt:Spanned<ExprInStmt>> ";" <cnt:Spanned<ExprStmt?>> => Expr::Seq {
        stmt: Box::new(stmt),
        cnt: Box::new(cnt.fmap(|cnt| cnt.unwrap_or(Expr::Lit { val: Lit::Unit }))),
    },
    ExprInStmt,
}

ExprInStmt: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <sym:Ident> "=" <bnd:Spanned<ExprLogicalOr<Struct>>> => Expr::Assign {
        sym,
        bnd: Box::new(bnd),
    },
    "if" <cnd:Spanned<ExprLogicalOr<Never>>> "{" <thn:Spanned<Expr>> "}" <l:@L> <els:("else" "{" <Spanned<Expr>> "}")?> <r:@R> => Expr::If {
        cnd: Box::new(cnd),
        thn: Box::new(thn),
        els: Box::new(els.unwrap_or(Meta { meta: (l, r - l), inner: Expr::Lit { val: Lit::Unit }})),
    },
    "loop" "{" <bdy:Spanned<Expr>> "}" => Expr::Loop {
        bdy: Box::new(bdy),
    },
    // todo: the spans in this desugaring do not make a lot sense.
    <l:@L> "while" <r:@R> <cnd:Spanned<ExprLogicalOr<Never>>> "{" <bdy:Spanned<Expr>> "}" => Expr::Loop {
        bdy: Box::new(Meta {
            meta: (l, r - l),
            inner: Expr::If {
                cnd: Box::new(cnd),
                thn: Box::new(bdy),
                els: Box::new(Meta {
                    meta: (l, r - l),
                    inner: Expr::Seq {
                        stmt: Box::new(Meta {
                            meta: (l, r - l),
                            inner: Expr::Break { bdy: Box::new(Meta {
                                meta: (l, r - l),
                                inner: Expr::Lit { val: Lit::Unit },
                            })},
                        }),
                        cnt: Box::new(Meta {
                            meta: (l, r - l),
                            inner: Expr::Lit { val: Lit::Unit },
                        }),
                    },
                }),
            },
        }),
    },
    "switch" <enm:Spanned<ExprLogicalOr<Never>>> "{" <arms:Comma<(<Ident> "(" <Ident> ")" "=>" <Spanned<Expr>> )>> "}"  => Expr::Switch {
        enm: Box::new(enm),
        arms: arms.into_iter().map(|(s1, s2, e)| (s1, s2, Box::new(e))).collect(),
     },
    "break" <bdy:Spanned<ExprLogicalOr<Struct>?>> => Expr::Break {
        bdy: Box::new(bdy.fmap(|bdy| bdy.unwrap_or(Expr::Lit { val: Lit::Unit }))),
    },
    "return" <bdy:Spanned<ExprLogicalOr<Struct>?>> => Expr::Return {
        bdy: Box::new(bdy.fmap(|bdy| bdy.unwrap_or(Expr::Lit { val: Lit::Unit }))),
    },
    "continue" => Expr::Continue,
    ExprLogicalOr<Struct>,
}

BinaryOps<Op,Next>: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <e1:Spanned<BinaryOps<Op,Next>>> <op:Op> <e2:Spanned<Next>> => Expr::BinaryOp {
        op,
        exprs: [Box::new(e1), Box::new(e2)],
    },
    Next,
}

ExprLogicalOr<T> = BinaryOps<LogicalOrOp, ExprLogicalAnd<T>>;
ExprLogicalAnd<T> = BinaryOps<LogicalAndOp, ExprComparative<T>>;
ExprComparative<T> = BinaryOps<ComparativeOp, ExprXor<T>>;
ExprXor<T> = BinaryOps<XorOp, ExprAdditive<T>>;
ExprAdditive<T> = BinaryOps<AdditiveOp, ExprMultiplicative<T>>;
ExprMultiplicative<T> = BinaryOps<MultiplicativeOp, ExprUnary<T>>;

LogicalOrOp: BinaryOp = "||" => BinaryOp::LOr;
LogicalAndOp: BinaryOp = "&&" => BinaryOp::LAnd;
ComparativeOp: BinaryOp = {
    "==" => BinaryOp::EQ,
    "!=" => BinaryOp::NE,
    ">" => BinaryOp::GT,
    ">=" => BinaryOp::GE,
    "<" => BinaryOp::LT,
    "<=" => BinaryOp::LE,
}
XorOp: BinaryOp = "^" => BinaryOp::Xor;
AdditiveOp: BinaryOp = {
    "+" => BinaryOp::Add,
    "-" => BinaryOp::Sub,
}
MultiplicativeOp: BinaryOp = {
   "*" => BinaryOp::Mul,
   "/" => BinaryOp::Div,
   "%" => BinaryOp::Mod,
}
UnaryOp: UnaryOp = {
    "-" => UnaryOp::Neg,
    "!" => UnaryOp::Not,
}

ExprUnary<T>: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <op:UnaryOp> <e:Spanned<ExprUnary<T>>> => Expr::UnaryOp {
        op,
        expr: Box::new(e),
    },
    ExprAccess<T>,
}

ExprAccess<T>: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <strct:Spanned<ExprAccess<T>>> "." <field:Ident> => Expr::AccessField {
        strct: Box::new(strct),
        field,
    },
    ExprCall<T>,
}

ExprCall<T>: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <fun:Spanned<ExprAtom<T>>> "(" <args:Comma<Spanned<Expr>>> ")" => Expr::Apply {
        fun: Box::new(fun),
        args,
    },
    ExprAtom<T>,
}

ExprAtom<T>: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <val:Num> => Expr::Lit { val: Lit::Int { val } },
    <val:Bool> => Expr::Lit { val: Lit::Bool { val } },
    "unit" => Expr::Lit { val: Lit::Unit },
    <sym:Ident> => Expr::Var { sym },
    <enum_sym:Ident> "::" <variant_sym:Ident> "(" <bdy:Spanned<Expr>> ")" => Expr::Variant {
        enum_sym,
        variant_sym,
        bdy: Box::new(bdy),
    },
    "(" <Expr> ")",
    <T>,
}

Struct: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {
    <sym:Ident> "{" <fields:Comma<StructArg>> "}" => Expr::Struct {
        sym,
        fields,
    },
}

StructArg : (Meta<Span, &'input str>, Meta<Span, Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span>>) = {
    <Ident> ":" <Spanned<Expr>>,
    <l:@L> <sym:Ident> <r:@R> => (sym.clone(), Meta { meta: (l, r - l), inner: Expr::Var { sym } })
}

Never: Expr<Meta<Span, &'input str>, Meta<Span, &'input str>, Lit<'input>, Span> = {};

Ident: Meta<Span, &'input str> = Spanned<identifier>;

Num: &'input str = <integer>;

Bool: bool = {
    "true" => true,
    "false" => false,
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None=> v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Spanned<T>: Meta<Span, T> = <l:@L> <inner:T> <r:@R> => Meta { meta: (l, r - l), inner };
